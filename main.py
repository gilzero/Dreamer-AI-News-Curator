# file: main.py
from fastapi import FastAPI, Request
from fastapi.responses import HTMLResponse, JSONResponse, FileResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from datetime import datetime
import os
from collections import defaultdict
import uvicorn

# Import from our modules
from config import Config, logger
from models import Article
from services import (
    ArticleFetcher, 
    try_tavily_extraction, 
    try_exa_extraction, 
    generate_fallback_content
)
from ai_services import generate_summary_with_gemini
from utils import datetimeformat
from config import GEMINI_API_KEY
from cache import get_cached_article_content

# Initialize FastAPI app
app = FastAPI(
    title="üïäÔ∏è Dreamer AI News Curator",
    description="AI-powered tech news curated just for you, with a beautiful bird-themed design",
    version="1.0.0"
)
app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

# Add custom datetime filter
templates.env.filters['datetimeformat'] = datetimeformat

# Routes
@app.get("/", response_class=HTMLResponse)
async def home(
    request: Request, 
    domains: str = None,
    articles_per_domain: int = None,
    lookback_days: int = None
):
    # Get configuration from query parameters or use defaults
    user_domains = domains.split(',') if domains else Config.DOMAINS
    user_articles_per_domain = articles_per_domain if articles_per_domain is not None else Config.ARTICLES_PER_DOMAIN
    user_lookback_days = lookback_days if lookback_days is not None else Config.LOOKBACK_DAYS
    
    # Create a custom config for this request
    custom_config = {
        'domains': user_domains,
        'articles_per_domain': user_articles_per_domain,
        'lookback_days': user_lookback_days
    }
    
    fetcher = ArticleFetcher(os.getenv('EXA_API_KEY', ''))
    articles = await fetcher.fetch_all(custom_config)

    grouped_articles = defaultdict(list)
    for article in articles:
        grouped_articles[article.source].append(article)

    return templates.TemplateResponse(
        "index.html",
        {
            "request": request,
            "grouped_articles": dict(grouped_articles),
            "config": custom_config,
            "domains_str": ','.join(user_domains)
        }
    )


@app.get("/favicon.ico", include_in_schema=False)
async def favicon(request: Request):
    return FileResponse("static/favicon.ico")


@app.get("/health")
async def health_check():
    return {"status": "ok", "timestamp": datetime.now().isoformat()}


@app.get("/extract")
async def extract_content(url: str):
    """
    Extract content from a URL using the Tavily Extract API with Exa API as fallback
    If both APIs fail or are not configured, returns a mock response
    Includes a Chinese summary generated by Google Gemini if available
    """
    # Extract domain from URL for domain-specific handling
    from urllib.parse import urlparse
    domain = urlparse(url).netloc
    
    # Check cache first for any content from this URL
    cached_content = await get_cached_article_content(url)
    if cached_content:
        logger.info(f"Using cached content for {url}")
        # If the cached content doesn't have a Chinese summary but we have Gemini API key,
        # generate and add the summary
        if GEMINI_API_KEY and "chinese_summary" not in cached_content:
            summary = await generate_summary_with_gemini(cached_content["content"], cached_content.get("title", ""))
            if summary:
                cached_content["chinese_summary"] = summary
        return cached_content
    
    # Try Tavily API first (better for article extraction)
    tavily_result = await try_tavily_extraction(url, domain)
    if tavily_result and not tavily_result.get("is_fallback"):
        # Add Chinese summary if Google API key is available
        if GEMINI_API_KEY:
            summary = await generate_summary_with_gemini(tavily_result["content"], tavily_result.get("title", ""))
            if summary:
                tavily_result["chinese_summary"] = summary
        return tavily_result
    
    # If Tavily failed or returned fallback, try Exa API
    exa_result = await try_exa_extraction(url, domain)
    if exa_result and not exa_result.get("is_fallback"):
        # Add Chinese summary if Google API key is available
        if GEMINI_API_KEY:
            summary = await generate_summary_with_gemini(exa_result["content"], exa_result.get("title", ""))
            if summary:
                exa_result["chinese_summary"] = summary
        return exa_result
    
    # If both APIs failed, use our fallback content
    logger.warning(f"Both Tavily and Exa APIs failed for {url}, using fallback content")
    fallback_content = generate_fallback_content(url, domain)
    return fallback_content


if __name__ == "__main__":
    # Basic startup validation
    if not os.path.exists('templates'):
        logger.error("Templates directory not found")
        exit(1)
    uvicorn.run(app, host="0.0.0.0", port=8081)